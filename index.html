<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clash Report Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            min-height: 100vh; /* Ensure body takes at least full viewport height */
            background-color: #f9fafb; /* Slightly off-white background */
        }
        main {
            flex-grow: 1; /* Allow main content to take available space */
        }
        /* Hide all page sections by default */
        .page-section {
            display: none;
        }
        /* Show the active page section */
        .page-section.active {
            display: block;
        }
        /* Styling for drag-and-drop areas */
         .drag-area {
            border: 2px dashed #cbd5e0; /* Tailwind gray-300 */
            border-radius: 0.5rem; /* Tailwind rounded-lg */
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.3s ease, background-color 0.3s ease;
            background-color: #fff;
        }
        .drag-area.dragover {
            border-color: #3b82f6; /* Tailwind blue-500 */
            background-color: #eff6ff; /* Tailwind blue-50 */
        }
        /* Hide the default file input */
        .hidden-input {
            display: none;
        }
        /* Style disabled buttons */
        .process-button:disabled,
        .export-button:disabled { /* Added common class for export buttons */
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #9ca3af; /* Tailwind gray-400 */
            border-color: #9ca3af;
        }
        /* Styling for message boxes (info, error, success, warning) */
        .message-box {
            background-color: #fff;
            border: 1px solid #e5e7eb; /* Tailwind gray-200 */
            padding: 1rem 1.5rem;
            margin-top: 1.5rem;
            border-radius: 0.5rem; /* Tailwind rounded-lg */
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06); /* Tailwind shadow-md */
            text-align: left;
            margin-left: auto;
            margin-right: auto;
            font-size: 0.9rem;
        }
        .message-box.error {
            border-left: 4px solid #ef4444; /* Tailwind red-500 */
            background-color: #fee2e2; /* Tailwind red-100 */
            color: #b91c1c; /* Tailwind red-800 */
        }
        .message-box.success {
            border-left: 4psolid #22c55e; /* Tailwind green-500 */
            background-color: #dcfce7; /* Tailwind green-100 */
            color: #14532d; /* Tailwind green-800 */
        }
         .message-box.warning {
            border-left: 4px solid #f59e0b; /* Tailwind amber-500 */
            background-color: #fffbeb; /* Tailwind amber-50 */
            color: #92400e; /* Tailwind amber-800 */
        }
        /* Styling for match status text */
        .match-status {
            font-weight: 600; /* Tailwind font-semibold */
            margin-top: 1.5rem; /* Increased margin top */
            text-align: center;
            padding: 0.5rem;
            border-radius: 0.375rem; /* Tailwind rounded-md */
        }
        .match-status.matched {
            color: #166534; /* Tailwind green-800 */
            /* background-color: #dcfce7; /* Tailwind green-100 - Removing background for closer match */
        }
        .match-status.not-matched {
            color: #dc2626; /* Tailwind red-600 - Matching image red */
            /* background-color: #fee2e2; /* Tailwind red-100 - Removing background */
        }
        /* Styling for column selection area */
        .column-selection {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid #e5e7eb; /* Tailwind gray-200 */
            text-align: left;
        }
        .column-selection h4 {
            font-weight: 600; /* Tailwind font-semibold */
            margin-bottom: 0.75rem;
            color: #1f2937; /* Tailwind gray-800 */
        }
        .column-selection label {
            margin-right: 1rem;
            font-size: 0.9rem;
            color: #4b5567; /* Tailwind gray-600 */
            display: inline-block; /* Ensure labels wrap nicely */
            margin-bottom: 0.5rem;
            cursor: pointer;
        }
        .column-selection input[type="checkbox"] {
             margin-right: 0.3rem;
             cursor: pointer;
             accent-color: #2563eb; /* Tailwind blue-600 */
        }
        /* Utility class to hide elements visually but keep accessible */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
        /* Style for summary labels */
        .summary-label {
            font-weight: 600; /* Tailwind font-semibold */
            color: #374151; /* Tailwind gray-700 */
            margin-right: 0.5rem; /* Space after colon */
        }
        /* Style for summary lists */
        .summary-list {
            list-disc: revert; /* Use standard disc bullets */
            list-style-position: inside;
            margin-left: 1rem; /* Indentation for bullets */
            margin-top: 0.25rem; /* Space above list */
        }
        .summary-list li {
            margin-bottom: 0.1rem; /* Small space between list items */
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-900">

    <header class="bg-blue-600 text-white p-4 shadow-md sticky top-0 z-10">
        <div class="container mx-auto flex justify-between items-center">
            <h1 class="text-2xl font-bold">Clash Report Analyzer</h1>
            </div>
    </header>

    <main class="container mx-auto px-4 py-8">

        <section id="landing-page" class="page-section active py-12 md:py-16 flex flex-col items-center justify-center text-center">
            <h2 class="text-3xl md:text-4xl font-bold mb-6 text-gray-800">Welcome to Clash Report Analyzer</h2>
            <p class="text-lg text-gray-700 mb-8 max-w-3xl mx-auto">
                Streamline your clash report workflow. Upload last week's and the current week's reports (.xlsx, .xls, .csv). This tool identifies matching items based on 'Set A Element' and 'Set B Element', then automatically copies values from selected columns of the previous report into corresponding empty cells in the current report. Download the updated report and a summary of changes.
            </p>
            <button id="getStartedButton" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-lg transition duration-300 ease-in-out shadow-lg focus:outline-none focus:ring-2 focus:ring-green-400 focus:ring-opacity-75">
                Get Started
            </button>
        </section>

        <section id="upload-page" class="page-section">
             <h2 class="text-3xl font-bold text-center mb-8 text-gray-800">Upload Clash Reports</h2>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-5xl mx-auto">

                <div class="bg-white p-6 rounded-lg shadow-lg border border-gray-200">
                    <h3 class="text-xl font-semibold mb-4 text-gray-700">1. Last Week Clash Report</h3>
                    <div id="lastWeekDragArea" class="drag-area flex flex-col items-center justify-center mb-4">
                        <svg class="w-12 h-12 text-gray-400 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
                        <p class="text-gray-600 mb-2">Drag & drop .xlsx, .xls, or .csv here</p>
                        <p class="text-gray-500 text-sm mb-2">or</p>
                        <label for="lastWeekFileInput" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out cursor-pointer focus-within:ring-2 focus-within:ring-blue-400 focus-within:ring-opacity-75">
                            Browse File
                        </label>
                        <input type="file" id="lastWeekFileInput" class="hidden-input" accept=".csv, .xls, .xlsx, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel">
                    </div>
                    <p id="lastWeekFileName" class="text-sm text-gray-700 mt-1 text-center min-h-[1.25rem]"></p> <div id="columnSelectionArea" class="column-selection hidden">
                         <h4 class="text-md">Select columns to copy values from:</h4>
                         <div id="columnCheckboxes" class="max-h-48 overflow-y-auto pr-2">
                             </div>
                     </div>
                </div>

                <div class="bg-white p-6 rounded-lg shadow-lg border border-gray-200">
                    <h3 class="text-xl font-semibold mb-4 text-gray-700">2. Current Week Clash Report</h3>
                    <div id="currentWeekDragArea" class="drag-area flex flex-col items-center justify-center mb-4">
                        <svg class="w-12 h-12 text-gray-400 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
                         <p class="text-gray-600 mb-2">Drag & drop .xlsx, .xls, or .csv here</p>
                        <p class="text-gray-500 text-sm mb-2">or</p>
                        <label for="currentWeekFileInput" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out cursor-pointer focus-within:ring-2 focus-within:ring-blue-400 focus-within:ring-opacity-75">
                            Browse File
                        </label>
                        <input type="file" id="currentWeekFileInput" class="hidden-input" accept=".csv, .xls, .xlsx, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel">
                    </div>
                    <p id="currentWeekFileName" class="text-sm text-gray-700 mt-1 text-center min-h-[1.25rem]"></p> </div>

            </div>

            <div class="text-center mt-10">
                <button id="processButton" class="process-button bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-12 rounded-lg transition duration-300 ease-in-out shadow-lg focus:outline-none focus:ring-2 focus:ring-green-400 focus:ring-opacity-75" disabled>
                    Process Reports
                </button>
            </div>

            <div id="uploadMessageBox" class="message-box hidden max-w-xl mx-auto mt-6">
                <p id="uploadMessageText"></p>
            </div>
        </section>

        <section id="results-page" class="page-section">
            <h2 class="text-3xl font-bold text-center mb-8 text-gray-800">Analysis Results</h2>

            <div class="bg-white p-6 rounded-lg shadow-md mb-8 max-w-4xl mx-auto border border-gray-200 text-gray-800 text-sm md:text-base">
                <h3 class="text-xl font-semibold mb-6 text-gray-700 border-b pb-2">Summary of Analysis</h3>
                <div id="analysisSummary" class="space-y-4"> <p>
                        <span class="summary-label">Selected columns for copying:</span>
                        <span id="selectedColumnsSummary">Loading...</span>
                    </p>
                     <p>
                        <span class="summary-label">Selected columns missing in Current Week report:</span>
                        <span id="missingColumnsSummary">Loading...</span>
                    </p>
                    <div>
                        <p><span class="summary-label">Total non-empty values (Last Week) in selected columns:</span></p>
                        <ul id="totalNonEmptyLastWeekSelected" class="summary-list"></ul>
                    </div>
                    <div>
                        <p><span class="summary-label">Total values copied to Current Week in selected columns:</span></p>
                        <ul id="totalCopiedSelected" class="summary-list"></ul>
                    </div>
                    <div>
                        <p><span class="summary-label">Total values not copied (Current Week had values) in selected columns:</span></p>
                         <ul id="totalNotCopiedSelected" class="summary-list"></ul>
                    </div>
                    <p>
                        <span class="summary-label">Total items missing in Current Week:</span>
                        <span id="totalMissingInCurrentWeek">Loading...</span>
                    </p>
                     <div>
                        <p><span class="summary-label">Non-empty values from Last Week (not found in Current Week) in selected columns:</span></p>
                        <ul id="totalMissingInCurrentWeekSelected" class="summary-list"></ul>
                    </div>
                </div>
                 <p id="matchStatus" class="match-status"></p> </div>

            <div class="text-center mt-10 space-y-4 md:space-y-0 md:space-x-4">
                <button id="exportButton" class="export-button w-full md:w-auto bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-8 rounded-lg transition duration-300 ease-in-out shadow-md focus:outline-none focus:ring-2 focus:ring-purple-400 focus:ring-opacity-75" disabled>
                    Download Updated Report
                </button>
                 <button id="exportNotCopiedButton" class="export-button w-full md:w-auto bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 px-8 rounded-lg transition duration-300 ease-in-out shadow-md focus:outline-none focus:ring-2 focus:ring-orange-400 focus:ring-opacity-75" disabled>
                    Download Not Copied / Missing Report
                </button>
                 <button id="goBackButton" class="w-full md:w-auto bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-8 rounded-lg transition duration-300 ease-in-out shadow-md focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-75">
                    Start Over
                </button>
            </div>

             <div id="resultsMessageBox" class="message-box hidden max-w-xl mx-auto mt-6">
                <p id="resultsMessageText"></p>
            </div>
        </section>

    </main>

    <footer class="bg-gray-200 text-gray-700 p-4 text-center mt-12 text-sm">
        <p>&copy; Developed by Guruprasath</p>
    </footer>

    <script>
        // --- Global Variables ---
        // Page navigation state
        const pages = ['landing-page', 'upload-page', 'results-page'];
        let currentPage = 'landing-page'; // Start on the landing page

        // File and data state (reset appropriately on navigation)
        let lastWeekFile = null;
        let currentWeekFile = null;
        let selectedColumns = []; // Stores unique keys of columns selected by the user
        let lastWeekHeaders = []; // Stores { uniqueKey, originalHeader, index } for last week
        let currentWeekHeaders = []; // Stores { uniqueKey, originalHeader, index } for current week

        // Processing results state (persist across navigation until 'Start Over')
        let processedReportData = null; // Holds the final data for the updated report (with unique keys)
        let notCopiedRows = []; // Holds current week rows that prevented a copy (with unique keys)
        let lastWeekNotCopiedRows = []; // Holds last week rows that weren't copied (with unique keys)
        let missingInCurrentWeekRows = []; // Holds last week rows missing in current week (with unique keys)
        let missingColumnsInCurrentWeek = []; // Holds unique keys of selected columns missing in current week
        let finalExportHeaders = []; // Holds the ordered list of original header names for the main export file

        // DOM Element References (cached for performance)
        const domElements = {
            getStartedButton: document.getElementById('getStartedButton'),
            lastWeekDragArea: document.getElementById('lastWeekDragArea'),
            lastWeekFileInput: document.getElementById('lastWeekFileInput'),
            lastWeekFileName: document.getElementById('lastWeekFileName'),
            columnSelectionArea: document.getElementById('columnSelectionArea'),
            columnCheckboxesDiv: document.getElementById('columnCheckboxes'),
            currentWeekDragArea: document.getElementById('currentWeekDragArea'),
            currentWeekFileInput: document.getElementById('currentWeekFileInput'),
            currentWeekFileName: document.getElementById('currentWeekFileName'),
            processButton: document.getElementById('processButton'),
            uploadMessageBox: document.getElementById('uploadMessageBox'),
            uploadMessageText: document.getElementById('uploadMessageText'),
            // Summary elements (updated IDs/structure)
            selectedColumnsSummary: document.getElementById('selectedColumnsSummary'),
            missingColumnsSummary: document.getElementById('missingColumnsSummary'),
            totalNonEmptyLastWeekSelected: document.getElementById('totalNonEmptyLastWeekSelected'), // UL element
            totalCopiedSelected: document.getElementById('totalCopiedSelected'), // UL element
            totalNotCopiedSelected: document.getElementById('totalNotCopiedSelected'), // UL element
            totalMissingInCurrentWeek: document.getElementById('totalMissingInCurrentWeek'), // Span element
            totalMissingInCurrentWeekSelected: document.getElementById('totalMissingInCurrentWeekSelected'), // UL element
            matchStatus: document.getElementById('matchStatus'), // P element
            // Other elements
            exportButton: document.getElementById('exportButton'),
            exportNotCopiedButton: document.getElementById('exportNotCopiedButton'),
            goBackButton: document.getElementById('goBackButton'),
            resultsMessageBox: document.getElementById('resultsMessageBox'),
            resultsMessageText: document.getElementById('resultsMessageText'),
        };

        // --- Utility Functions ---

        // Helper function to check if a property exists on an object safely
        function hasProp(obj, key) {
            return Object.prototype.hasOwnProperty.call(obj, key);
        }

        // Function to truncate sheet names to Excel's 31-character limit
        function truncateSheetName(name) {
            const maxLength = 31;
            // Remove invalid characters: * ? : / \ [ ]
            const sanitizedName = name.replace(/[*?:/\\\[\]]/g, '');
            return sanitizedName.length > maxLength ? sanitizedName.substring(0, maxLength) : sanitizedName;
        }

        // Function to read file as binary string using FileReader API
        function readFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error(`File could not be read: ${e.target.error}`));
                reader.readAsBinaryString(file); // Read as binary string for SheetJS
            });
        }

        // --- Message Display Functions ---

        // Show messages on the upload page
        function showUploadMessage(text, type = 'info') {
            domElements.uploadMessageText.innerHTML = text; // Use innerHTML for potential formatting
            domElements.uploadMessageBox.className = 'message-box max-w-xl mx-auto mt-6'; // Reset classes
            if (type === 'error') domElements.uploadMessageBox.classList.add('error');
            else if (type === 'success') domElements.uploadMessageBox.classList.add('success');
            else if (type === 'warning') domElements.uploadMessageBox.classList.add('warning');
            domElements.uploadMessageBox.classList.remove('hidden');
        }

        // Hide messages on the upload page
        function hideUploadMessage() {
            domElements.uploadMessageBox.classList.add('hidden');
            domElements.uploadMessageText.innerHTML = '';
        }

        // Show messages on the results page
        function showResultsMessage(text, type = 'info') {
            domElements.resultsMessageText.innerHTML = text; // Use innerHTML
            domElements.resultsMessageBox.className = 'message-box max-w-xl mx-auto mt-6'; // Reset classes
            if (type === 'error') domElements.resultsMessageBox.classList.add('error');
            else if (type === 'success') domElements.resultsMessageBox.classList.add('success');
            else if (type === 'warning') domElements.resultsMessageBox.classList.add('warning');
            domElements.resultsMessageBox.classList.remove('hidden');
        }

        // Hide messages on the results page
        function hideResultsMessage() {
            domElements.resultsMessageBox.classList.add('hidden');
            domElements.resultsMessageText.innerHTML = '';
        }

        // --- Page Navigation ---

        // Function to show a specific page and hide others
        function showPage(pageId) {
            console.log(`Navigating to page: ${pageId}`);
            pages.forEach(id => {
                const pageElement = document.getElementById(id);
                if (pageElement) {
                    if (id === pageId) {
                        pageElement.classList.add('active');
                        pageElement.style.display = 'block'; // Ensure display is block
                    } else {
                        pageElement.classList.remove('active');
                        pageElement.style.display = 'none'; // Ensure display is none
                    }
                }
            });
            currentPage = pageId;

            // Reset Upload Page State when navigating TO it (unless coming from landing)
            if (pageId === 'upload-page') {
                 resetUploadForm();
                 checkFilesAndEnableButton();
            }
            // Clear results messages when leaving the results page
            if (pageId !== 'results-page') {
                hideResultsMessage();
            }
             // Clear upload messages when leaving the upload page
            if (pageId !== 'upload-page') {
                hideUploadMessage();
            }
        }

        // Resets the upload form elements (files, names, checkboxes)
        function resetUploadForm() {
            console.log("Resetting upload form elements.");
             domElements.lastWeekFileInput.value = '';
             domElements.currentWeekFileInput.value = '';
             lastWeekFile = null;
             currentWeekFile = null;
             selectedColumns = [];
             lastWeekHeaders = [];
             currentWeekHeaders = [];
             missingColumnsInCurrentWeek = [];
             domElements.lastWeekFileName.textContent = '';
             domElements.currentWeekFileName.textContent = '';
             domElements.lastWeekFileName.classList.remove('text-red-500', 'text-green-600');
             domElements.currentWeekFileName.classList.remove('text-red-500', 'text-green-600');
             domElements.columnSelectionArea.classList.add('hidden');
             domElements.columnCheckboxesDiv.innerHTML = '';
             domElements.processButton.disabled = true;
             domElements.processButton.textContent = 'Process Reports';
             domElements.processButton.classList.add('process-button:disabled');
             hideUploadMessage();
             domElements.exportButton.disabled = true;
             domElements.exportNotCopiedButton.disabled = true;
        }

        // --- File Handling and Parsing ---

        function parseFile(data, fileName) {
            console.log(`Parsing file: ${fileName}`);
            try {
                const workbook = XLSX.read(data, { type: 'binary' });
                const sheetName = workbook.SheetNames[0];
                if (!sheetName) throw new Error("No sheets found in the workbook.");
                const worksheet = workbook.Sheets[sheetName];
                if (!worksheet) throw new Error(`Sheet "${sheetName}" could not be read.`);
                const jsonArray = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });

                if (!jsonArray || jsonArray.length === 0) throw new Error("File appears to be empty.");

                const headerRow = jsonArray[0];
                const processedData = [];
                const headersInfo = [];
                if (!headerRow || headerRow.length === 0) throw new Error("File is missing a header row.");

                const headerIndices = {};
                headerRow.forEach((header, index) => {
                    const originalHeader = String(header || '').trim();
                    if (originalHeader === '') {
                        console.warn(`File "${fileName}", Column ${index + 1}: Header is empty, skipping.`);
                        return;
                    }
                    const uniqueColumnKey = `${originalHeader}__${index}`;
                    headersInfo.push({ uniqueKey: uniqueColumnKey, originalHeader: originalHeader, index: index });
                    headerIndices[originalHeader] = (headerIndices[originalHeader] || 0) + 1;
                });

                Object.entries(headerIndices).forEach(([header, count]) => {
                    if (count > 1) console.warn(`File "${fileName}": Header "${header}" appears ${count} times. Using original column index for uniqueness.`);
                });
                console.log(`Parsed ${headersInfo.length} headers for ${fileName}.`);

                const requiredHeaders = ['Set A Element', 'Set B Element'];
                const foundRequiredHeaders = requiredHeaders.filter(reqHeader => headersInfo.some(h => h.originalHeader === reqHeader));
                if (foundRequiredHeaders.length !== requiredHeaders.length) {
                    const missing = requiredHeaders.filter(reqHeader => !foundRequiredHeaders.includes(reqHeader));
                    throw new Error(`Missing required columns for matching: ${missing.join(', ')}. Please ensure the file has columns with these exact header names.`);
                }

                if (jsonArray.length > 1) {
                    const dataRows = jsonArray.slice(1);
                    dataRows.forEach((row, rowIndex) => {
                        if (!row || row.every(cell => String(cell || '').trim() === '')) {
                            console.warn(`File "${fileName}", Row ${rowIndex + 2}: Skipping empty row.`);
                            return;
                        }
                        const rowObject = {};
                        headersInfo.forEach(headerInfo => {
                            rowObject[headerInfo.uniqueKey] = row[headerInfo.index];
                        });
                        processedData.push(rowObject);
                    });
                    console.log(`Parsed ${processedData.length} data rows for ${fileName}.`);
                } else {
                     console.warn(`File "${fileName}" only contains a header row.`);
                }
                return { data: processedData, headers: headersInfo };
            } catch (error) {
                console.error(`Error parsing file "${fileName}":`, error);
                throw new Error(`Error parsing file "${fileName}": ${error.message || error}`);
            }
        }

        async function handleFileSelect(file, fileNameElement, dragAreaElement, isLastWeek = false) {
            console.log(`Handling file select for ${isLastWeek ? 'Last Week' : 'Current Week'}:`, file ? file.name : 'No file');
            hideUploadMessage();
            fileNameElement.textContent = '';
            fileNameElement.classList.remove('text-red-500', 'text-green-600');
            dragAreaElement.classList.remove('dragover');

            if (isLastWeek) {
                domElements.columnSelectionArea.classList.add('hidden');
                domElements.columnCheckboxesDiv.innerHTML = '';
                selectedColumns = [];
                lastWeekHeaders = [];
            } else {
                currentWeekHeaders = [];
            }

            if (!file) {
                fileNameElement.textContent = 'No file selected.';
                checkFilesAndEnableButton();
                checkForMissingColumnsWarning();
                return null;
            }

            const allowedExtensions = ['.csv', '.xls', '.xlsx'];
            const fileExtension = '.' + file.name.split('.').pop().toLowerCase();
            if (!allowedExtensions.includes(fileExtension)) {
                fileNameElement.textContent = `Invalid file type: ${file.name}. Please use .csv, .xls, or .xlsx.`;
                fileNameElement.classList.add('text-red-500');
                checkFilesAndEnableButton();
                return null;
            }

            fileNameElement.textContent = `Processing: ${file.name}...`;

            try {
                const data = await readFile(file);
                const parsedResult = parseFile(data, file.name);

                if (isLastWeek) {
                    lastWeekHeaders = parsedResult.headers;
                    populateColumnCheckboxes(lastWeekHeaders);
                } else {
                    currentWeekHeaders = parsedResult.headers;
                }

                fileNameElement.textContent = `File ready: ${file.name}`;
                fileNameElement.classList.add('text-green-600');
                checkFilesAndEnableButton();
                checkForMissingColumnsWarning();
                return file;

            } catch (error) {
                console.error("Error during file handling/parsing:", error);
                fileNameElement.textContent = `Error: ${error.message}`;
                fileNameElement.classList.add('text-red-500');
                if (isLastWeek) {
                    domElements.columnSelectionArea.classList.add('hidden');
                    domElements.columnCheckboxesDiv.innerHTML = '';
                    selectedColumns = [];
                    lastWeekHeaders = [];
                } else {
                    currentWeekHeaders = [];
                }
                checkFilesAndEnableButton();
                return null;
            }
        }

        function populateColumnCheckboxes(headers) {
            domElements.columnCheckboxesDiv.innerHTML = '';
            selectedColumns = [];

            if (headers && headers.length > 0) {
                headers.forEach(headerInfo => {
                    const div = document.createElement('div');
                    div.classList.add('mb-1');
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `col-${headerInfo.uniqueKey}`;
                    checkbox.value = headerInfo.uniqueKey;
                    const label = document.createElement('label');
                    label.htmlFor = `col-${headerInfo.uniqueKey}`;
                    label.textContent = `${headerInfo.originalHeader} (Col ${headerInfo.index + 1})`;
                    div.appendChild(checkbox);
                    div.appendChild(label);
                    domElements.columnCheckboxesDiv.appendChild(div);

                    checkbox.addEventListener('change', (event) => {
                        if (event.target.checked) {
                            selectedColumns.push(event.target.value);
                        } else {
                            selectedColumns = selectedColumns.filter(colKey => colKey !== event.target.value);
                        }
                        console.log("Selected Columns (Unique Keys):", selectedColumns);
                        checkFilesAndEnableButton();
                        checkForMissingColumnsWarning();
                    });
                });
                domElements.columnSelectionArea.classList.remove('hidden');
            } else {
                 domElements.columnSelectionArea.classList.add('hidden');
            }
        }

        function checkFilesAndEnableButton() {
            const enabled = lastWeekFile && currentWeekFile && selectedColumns.length > 0;
            domElements.processButton.disabled = !enabled;
            domElements.processButton.classList.toggle('process-button:disabled', !enabled);
        }

        function checkForMissingColumnsWarning() {
             if (lastWeekHeaders.length > 0 && currentWeekHeaders.length > 0 && selectedColumns.length > 0) {
                 const currentWeekUniqueKeys = new Set(currentWeekHeaders.map(h => h.uniqueKey));
                 const missingCols = selectedColumns.filter(selectedKey => !currentWeekUniqueKeys.has(selectedKey));

                 if (missingCols.length > 0) {
                     const missingColumnNames = missingCols.map(selectedKey => {
                          const headerInfo = lastWeekHeaders.find(h => h.uniqueKey === selectedKey);
                          return headerInfo ? `"${headerInfo.originalHeader}" (Col ${headerInfo.index + 1})` : `"${selectedKey}"`;
                     }).join(', ');
                     showUploadMessage(`<strong>Warning:</strong> Selected columns missing in Current Week report: ${missingColumnNames}. These columns will be added to the output, and values copied where applicable.`, 'warning');
                 } else {
                      if (domElements.uploadMessageBox.classList.contains('warning')) {
                          hideUploadMessage();
                      }
                 }
             } else {
                 if (domElements.uploadMessageBox.classList.contains('warning')) {
                     hideUploadMessage();
                 }
             }
        }

        function addDragDropListeners(dragArea, fileInput, isLastWeek = false) {
            dragArea.addEventListener('dragover', (event) => {
                event.preventDefault();
                dragArea.classList.add('dragover');
            });
            dragArea.addEventListener('dragleave', () => {
                dragArea.classList.remove('dragover');
            });
            dragArea.addEventListener('drop', async (event) => {
                event.preventDefault();
                dragArea.classList.remove('dragover');
                const files = event.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    const fileNameElement = document.getElementById(fileInput.id.replace('FileInput', 'FileName'));
                    const fileResult = await handleFileSelect(file, fileNameElement, dragArea, isLastWeek);
                    if (isLastWeek) lastWeekFile = fileResult;
                    else currentWeekFile = fileResult;
                }
            });
            dragArea.addEventListener('click', (e) => {
                if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'LABEL') {
                    fileInput.click();
                }
            });
        }

        // --- Core Processing Logic ---

        function processClashReports(lastWeekParsed, currentWeekParsed, columnsToCopyUniqueKeys) {
            console.log("Starting clash report processing...");
            console.log("Columns selected for copying (Unique Keys):", columnsToCopyUniqueKeys);

            const lastWeekData = lastWeekParsed.data;
            const lastWeekHeadersInfo = lastWeekParsed.headers;
            const currentWeekData = currentWeekParsed.data;
            const currentWeekHeadersInfo = currentWeekParsed.headers;

            const currentWeekUniqueKeysSet = new Set(currentWeekHeadersInfo.map(h => h.uniqueKey));
            const missingSelectedColumnKeys = columnsToCopyUniqueKeys.filter(key => !currentWeekUniqueKeysSet.has(key));
            console.log("Selected columns missing in Current Week (Keys):", missingSelectedColumnKeys);

            const processedDataMap = new Map();
            const finalProcessedData = [];

            const setAKeyCurrentInfo = currentWeekHeadersInfo.find(h => h.originalHeader === 'Set A Element');
            const setBKeyCurrentInfo = currentWeekHeadersInfo.find(h => h.originalHeader === 'Set B Element');
            if (!setAKeyCurrentInfo || !setBKeyCurrentInfo) throw new Error("Critical Error: Could not find 'Set A Element' or 'Set B Element' keys in current week headers during processing.");
            const setAKeyCurrent = setAKeyCurrentInfo.uniqueKey;
            const setBKeyCurrent = setBKeyCurrentInfo.uniqueKey;

            currentWeekData.forEach(row => {
                const rowCopy = JSON.parse(JSON.stringify(row));
                missingSelectedColumnKeys.forEach(missingKey => {
                    if (!hasProp(rowCopy, missingKey)) rowCopy[missingKey] = '';
                });
                const valA = String(rowCopy[setAKeyCurrent] || '').trim();
                const valB = String(rowCopy[setBKeyCurrent] || '').trim();
                const matchKey = `${valA}__${valB}`;
                processedDataMap.set(matchKey, rowCopy);
                finalProcessedData.push(rowCopy);
            });
            console.log(`Created processedDataMap with ${processedDataMap.size} entries.`);

            const summary = {
                totalNonEmptyLastWeek: {}, totalCopied: {}, totalNotCopied: {},
                totalMissingInCurrentWeek: 0, totalMissingInCurrentWeekNonEmpty: {}
            };
            columnsToCopyUniqueKeys.forEach(key => {
                summary.totalNonEmptyLastWeek[key] = 0; summary.totalCopied[key] = 0;
                summary.totalNotCopied[key] = 0; summary.totalMissingInCurrentWeekNonEmpty[key] = 0;
            });

            const resultRows = { notCopiedCurrentWeek: [], notCopiedLastWeek: [], missingInCurrentWeek: [] };

            const setAKeyLastWeekInfo = lastWeekHeadersInfo.find(h => h.originalHeader === 'Set A Element');
            const setBKeyLastWeekInfo = lastWeekHeadersInfo.find(h => h.originalHeader === 'Set B Element');
            if (!setAKeyLastWeekInfo || !setBKeyLastWeekInfo) throw new Error("Critical Error: Could not find 'Set A Element' or 'Set B Element' keys in last week headers during processing.");
            const setAKeyLastWeek = setAKeyLastWeekInfo.uniqueKey;
            const setBKeyLastWeek = setBKeyLastWeekInfo.uniqueKey;

            lastWeekData.forEach((lastWeekRow) => {
                const valA = String(lastWeekRow[setAKeyLastWeek] || '').trim();
                const valB = String(lastWeekRow[setBKeyLastWeek] || '').trim();
                const matchKey = `${valA}__${valB}`;

                columnsToCopyUniqueKeys.forEach(key => {
                    if (hasProp(lastWeekRow, key) && String(lastWeekRow[key] || '').trim() !== '') {
                        summary.totalNonEmptyLastWeek[key]++;
                    }
                });

                const processedRow = processedDataMap.get(matchKey);

                if (processedRow) {
                    let rowAddedToNotCopied = false;
                    columnsToCopyUniqueKeys.forEach(key => {
                        if (hasProp(lastWeekRow, key) && hasProp(processedRow, key)) {
                            const lastValue = String(lastWeekRow[key] || '').trim();
                            const currentValue = String(processedRow[key] || '').trim();
                            if (lastValue !== '') {
                                if (currentValue === '') {
                                    processedRow[key] = lastWeekRow[key];
                                    summary.totalCopied[key]++;
                                } else {
                                    summary.totalNotCopied[key]++;
                                    if (!rowAddedToNotCopied) {
                                         resultRows.notCopiedLastWeek.push(lastWeekRow);
                                         const originalCurrentRow = currentWeekData.find(currentRow => {
                                             const currentValA = String(currentRow[setAKeyCurrent] || '').trim();
                                             const currentValB = String(currentRow[setBKeyCurrent] || '').trim();
                                             return `${currentValA}__${currentValB}` === matchKey;
                                         });
                                         if (originalCurrentRow) resultRows.notCopiedCurrentWeek.push(originalCurrentRow);
                                         else {
                                             console.warn(`Could not find original current week row for match key ${matchKey} when adding to notCopiedCurrentWeek.`);
                                             resultRows.notCopiedCurrentWeek.push(JSON.parse(JSON.stringify(processedRow)));
                                         }
                                         rowAddedToNotCopied = true;
                                    }
                                }
                            }
                        } else {
                             console.warn(`Column key ${key} missing in lastWeekRow or processedRow for match key ${matchKey}. Skipping copy.`);
                        }
                    });
                } else {
                    summary.totalMissingInCurrentWeek++;
                    resultRows.missingInCurrentWeek.push(lastWeekRow);
                    columnsToCopyUniqueKeys.forEach(key => {
                        if (hasProp(lastWeekRow, key) && String(lastWeekRow[key] || '').trim() !== '') {
                            summary.totalMissingInCurrentWeekNonEmpty[key]++;
                        }
                    });
                }
            });

            console.log("Processing complete.");
            console.log("Summary:", summary);
            console.log("Not Copied (Current Week):", resultRows.notCopiedCurrentWeek.length);
            console.log("Not Copied (Last Week):", resultRows.notCopiedLastWeek.length);
            console.log("Missing in Current Week:", resultRows.missingInCurrentWeek.length);

            return {
                summary: summary, processedData: finalProcessedData,
                notCopiedRows: resultRows.notCopiedCurrentWeek, lastWeekNotCopiedRows: resultRows.notCopiedLastWeek,
                missingInCurrentWeekRows: resultRows.missingInCurrentWeek, missingColumnsInCurrentWeek: missingSelectedColumnKeys
            };
        }

        // --- Results Display ---

        // UPDATED function to display results on the results page with new format
        function displayResults(summary, selectedColsUniqueKeys, missingColsUniqueKeys) {
             console.log("Displaying results (updated format)...");
             hideResultsMessage();

             missingColumnsInCurrentWeek = missingColsUniqueKeys || [];

             // Helper to get display name (Original Header (Col X))
             const getHeaderName = (key) => {
                 const headerInfo = lastWeekHeaders.find(h => h.uniqueKey === key);
                 // Fallback for keys that might somehow not be in lastWeekHeaders (e.g., if only present in current)
                 if (!headerInfo) {
                     const currentHeaderInfo = currentWeekHeaders.find(h => h.uniqueKey === key);
                     return currentHeaderInfo ? `${currentHeaderInfo.originalHeader} (Col ${currentHeaderInfo.index + 1})` : key;
                 }
                 return `${headerInfo.originalHeader} (Col ${headerInfo.index + 1})`;
             };

             // --- Populate Summary Section (Updated Logic) ---
             domElements.selectedColumnsSummary.textContent = selectedColsUniqueKeys.length > 0
                 ? selectedColsUniqueKeys.map(getHeaderName).join(', ')
                 : 'None'; // Match image format

             domElements.missingColumnsSummary.textContent = missingColumnsInCurrentWeek.length > 0
                 ? missingColumnsInCurrentWeek.map(getHeaderName).join(', ')
                 : 'None'; // Match image format

             // Function to populate a list element (ul) - slightly adjusted text
             const populateList = (ulElement, dataObject) => {
                 ulElement.innerHTML = ''; // Clear previous
                 if (selectedColsUniqueKeys.length === 0) {
                     // Don't add 'N/A' if no columns selected, just leave the list empty
                     return;
                 }
                 let itemsAdded = 0;
                 selectedColsUniqueKeys.forEach(key => {
                     const li = document.createElement('li');
                     // Format: Comments (Column 3): 13
                     li.textContent = `${getHeaderName(key)}: ${dataObject[key] || 0}`;
                     ulElement.appendChild(li);
                     itemsAdded++;
                 });
                 // If no items were actually added (e.g., all counts were 0), maybe add a placeholder?
                 // Or leave it empty as per the image. Let's leave it empty.
             };

             // Populate the UL elements
             populateList(domElements.totalNonEmptyLastWeekSelected, summary.totalNonEmptyLastWeek);
             populateList(domElements.totalCopiedSelected, summary.totalCopied);
             populateList(domElements.totalNotCopiedSelected, summary.totalNotCopied);
             populateList(domElements.totalMissingInCurrentWeekSelected, summary.totalMissingInCurrentWeekNonEmpty);

             // Populate the single span element
             domElements.totalMissingInCurrentWeek.textContent = summary.totalMissingInCurrentWeek;

             // --- Calculate and Display Match Status (Updated Logic) ---
             let countsMatch = true;
             if (selectedColsUniqueKeys.length > 0) {
                 selectedColsUniqueKeys.forEach(key => {
                     const sumForCol = (summary.totalCopied[key] || 0) + (summary.totalNotCopied[key] || 0) + (summary.totalMissingInCurrentWeekNonEmpty[key] || 0);
                     const totalNonEmpty = summary.totalNonEmptyLastWeek[key] || 0;
                     if (sumForCol !== totalNonEmpty) {
                         countsMatch = false;
                         console.warn(`Count mismatch for column ${getHeaderName(key)}: Sum=${sumForCol}, Expected=${totalNonEmpty}`);
                     }
                 });

                 domElements.matchStatus.classList.remove('matched', 'not-matched'); // Remove previous classes
                 if (countsMatch) {
                     domElements.matchStatus.textContent = "Count matched";
                     domElements.matchStatus.classList.add('matched'); // Apply green color class
                 } else {
                     domElements.matchStatus.textContent = "Count not matched";
                     domElements.matchStatus.classList.add('not-matched'); // Apply red color class
                 }
             } else {
                  // If no columns selected, display nothing
                  domElements.matchStatus.textContent = "";
                  domElements.matchStatus.classList.remove('matched', 'not-matched'); // Ensure no classes are left
             }

            // --- Enable/Disable Export Buttons ---
            domElements.exportButton.disabled = !processedReportData || processedReportData.length === 0;
            domElements.exportNotCopiedButton.disabled =
                (!lastWeekNotCopiedRows || lastWeekNotCopiedRows.length === 0) &&
                (!notCopiedRows || notCopiedRows.length === 0) &&
                (!missingInCurrentWeekRows || missingInCurrentWeekRows.length === 0);

             // --- Generate Final Export Headers ---
             generateFinalExportHeaders(); // This remains the same
        }

        // Generates the ordered list of header names for the main export file
        function generateFinalExportHeaders() {
            finalExportHeaders = [];
            const addedHeaderNames = new Set();

            currentWeekHeaders.forEach(headerInfo => {
                finalExportHeaders.push(headerInfo.originalHeader);
                addedHeaderNames.add(headerInfo.originalHeader);
            });

            missingColumnsInCurrentWeek.forEach(missingKey => {
                 const lastWeekHeaderInfo = lastWeekHeaders.find(h => h.uniqueKey === missingKey);
                 if (lastWeekHeaderInfo) {
                     let headerToAdd = lastWeekHeaderInfo.originalHeader;
                     if (addedHeaderNames.has(headerToAdd)) {
                          headerToAdd = `${headerToAdd} (From LW Col ${lastWeekHeaderInfo.index + 1})`;
                          console.warn(`Header "${lastWeekHeaderInfo.originalHeader}" was already present. Appending column info for export header: "${headerToAdd}"`);
                     }
                     finalExportHeaders.push(headerToAdd);
                 } else {
                      console.error(`Could not find header info for missing key ${missingKey} when generating export headers.`);
                      finalExportHeaders.push(missingKey);
                 }
            });
            console.log("Final export headers generated:", finalExportHeaders);
        }


        // --- Data Export ---

        function dataToWorksheet(data, headers) {
             console.log(`Creating worksheet with ${data ? data.length : 0} rows and ${headers ? headers.length : 0} headers.`);
             if (!data || data.length === 0 || !headers || headers.length === 0) {
                 console.warn("Cannot create worksheet: No data or headers provided.");
                 return null;
             }
             try {
                 const sheetData = [headers];
                 data.forEach(row => {
                     const rowArray = headers.map(header => row[header] !== undefined ? row[header] : '');
                     sheetData.push(rowArray);
                 });
                 const worksheet = XLSX.utils.aoa_to_sheet(sheetData);
                 console.log("Worksheet created successfully.");
                 return worksheet;
             } catch (error) {
                 console.error("Error creating worksheet:", error);
                 throw new Error(`Error creating worksheet: ${error.message || error}`);
             }
        }

        function prepareRowForExport(row, headerMap) {
             const exportRow = {};
             for (const headerName in headerMap) {
                 if (hasProp(headerMap, headerName)) {
                     const uniqueKey = headerMap[headerName];
                     exportRow[headerName] = hasProp(row, uniqueKey) ? row[uniqueKey] : '';
                 }
             }
             return exportRow;
        }

        function prepareOriginalRowForExport(row, headersInfo) {
             const exportRow = {};
             headersInfo.forEach(headerInfo => {
                 exportRow[headerInfo.originalHeader] = hasProp(row, headerInfo.uniqueKey) ? row[headerInfo.uniqueKey] : '';
             });
             return exportRow;
        }


        // --- Event Listeners Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded. Setting up event listeners.");

            showPage('landing-page');

            domElements.getStartedButton?.addEventListener('click', () => showPage('upload-page'));

            domElements.lastWeekFileInput?.addEventListener('change', async (event) => {
                const file = event.target.files ? event.target.files[0] : null;
                lastWeekFile = await handleFileSelect(file, domElements.lastWeekFileName, domElements.lastWeekDragArea, true);
            });
            domElements.currentWeekFileInput?.addEventListener('change', async (event) => {
                const file = event.target.files ? event.target.files[0] : null;
                currentWeekFile = await handleFileSelect(file, domElements.currentWeekFileName, domElements.currentWeekDragArea, false);
            });

            if (domElements.lastWeekDragArea && domElements.lastWeekFileInput) {
                addDragDropListeners(domElements.lastWeekDragArea, domElements.lastWeekFileInput, true);
            }
            if (domElements.currentWeekDragArea && domElements.currentWeekFileInput) {
                addDragDropListeners(domElements.currentWeekDragArea, domElements.currentWeekFileInput, false);
            }

            domElements.processButton?.addEventListener('click', async () => {
                if (domElements.processButton.disabled) return;
                hideUploadMessage();
                domElements.processButton.disabled = true;
                domElements.processButton.textContent = 'Processing...';

                try {
                    console.log("Reparsing files before processing...");
                    const lastWeekData = await readFile(lastWeekFile);
                    const lastWeekParsed = parseFile(lastWeekData, lastWeekFile.name);
                    lastWeekHeaders = lastWeekParsed.headers; // Update global headers

                    const currentWeekData = await readFile(currentWeekFile);
                    const currentWeekParsed = parseFile(currentWeekData, currentWeekFile.name);
                    currentWeekHeaders = currentWeekParsed.headers; // Update global headers

                    console.log("Starting core processing...");
                    const results = processClashReports(lastWeekParsed, currentWeekParsed, selectedColumns);

                    processedReportData = results.processedData;
                    notCopiedRows = results.notCopiedRows;
                    lastWeekNotCopiedRows = results.lastWeekNotCopiedRows;
                    missingInCurrentWeekRows = results.missingInCurrentWeekRows;

                    // Display results (calls generateFinalExportHeaders internally)
                    displayResults(results.summary, selectedColumns, results.missingColumnsInCurrentWeek);

                    showPage('results-page');
                    showResultsMessage("Processing complete. Review the summary and download reports.", "success");

                } catch (error) {
                    console.error("Processing error:", error);
                    showUploadMessage(`Processing failed: ${error.message}`, 'error');
                    domElements.processButton.disabled = false; // Re-enable on failure
                    domElements.processButton.textContent = 'Process Reports';
                    checkFilesAndEnableButton();
                }
            });

            domElements.exportButton?.addEventListener('click', () => {
                if (domElements.exportButton.disabled || !processedReportData || finalExportHeaders.length === 0) return;
                console.log("Exporting Updated Report...");
                hideResultsMessage();
                try {
                    const headerMap = {};
                    finalExportHeaders.forEach(headerName => {
                         let headerInfo = currentWeekHeaders.find(h => h.originalHeader === headerName);
                         if (headerInfo) {
                             headerMap[headerName] = headerInfo.uniqueKey;
                         } else {
                             headerInfo = lastWeekHeaders.find(h =>
                                 h.originalHeader === headerName ||
                                 `${h.originalHeader} (From LW Col ${h.index + 1})` === headerName
                             );
                             if (headerInfo && missingColumnsInCurrentWeek.includes(headerInfo.uniqueKey)) {
                                 headerMap[headerName] = headerInfo.uniqueKey;
                             } else {
                                 console.warn(`Could not map export header "${headerName}" back to a unique key.`);
                                 headerMap[headerName] = null;
                             }
                         }
                    });
                    console.log("Header map for export:", headerMap);

                    const dataForExport = processedReportData.map(row => {
                         const exportRow = {};
                         finalExportHeaders.forEach(headerName => {
                             const uniqueKey = headerMap[headerName];
                             exportRow[headerName] = (uniqueKey && hasProp(row, uniqueKey)) ? row[uniqueKey] : '';
                         });
                         return exportRow;
                    });

                    const worksheet = dataToWorksheet(dataForExport, finalExportHeaders);
                    if (worksheet) {
                        const workbook = XLSX.utils.book_new();
                        XLSX.utils.book_append_sheet(workbook, worksheet, "Updated Report");
                        const exportFileName = `Updated_${currentWeekFile.name}`;
                        XLSX.writeFile(workbook, exportFileName);
                        showResultsMessage(`Successfully exported "${exportFileName}".`, 'success');
                    } else {
                         throw new Error("Worksheet creation failed.");
                    }
                } catch (error) {
                    console.error("Error during Updated Report export:", error);
                    showResultsMessage(`Failed to export Updated Report: ${error.message}`, 'error');
                }
            });

            domElements.exportNotCopiedButton?.addEventListener('click', () => {
                 if (domElements.exportNotCopiedButton.disabled) return;
                 console.log("Exporting Not Copied / Missing Report...");
                 hideResultsMessage();
                 const workbook = XLSX.utils.book_new();
                 let sheetsAdded = 0;
                 try {
                     if (lastWeekNotCopiedRows && lastWeekNotCopiedRows.length > 0) {
                          const sheetName = truncateSheetName("LW Not Copied");
                          const headers = lastWeekHeaders.map(h => h.originalHeader);
                          const data = lastWeekNotCopiedRows.map(row => prepareOriginalRowForExport(row, lastWeekHeaders));
                          const worksheet = dataToWorksheet(data, headers);
                          if (worksheet) { XLSX.utils.book_append_sheet(workbook, worksheet, sheetName); sheetsAdded++; }
                     }
                     if (notCopiedRows && notCopiedRows.length > 0) {
                          const sheetName = truncateSheetName("CW Prevented Copy");
                          const headers = currentWeekHeaders.map(h => h.originalHeader);
                          const data = notCopiedRows.map(row => prepareOriginalRowForExport(row, currentWeekHeaders));
                          const worksheet = dataToWorksheet(data, headers);
                          if (worksheet) { XLSX.utils.book_append_sheet(workbook, worksheet, sheetName); sheetsAdded++; }
                     }
                     if (missingInCurrentWeekRows && missingInCurrentWeekRows.length > 0) {
                          const sheetName = truncateSheetName("LW Missing in CW");
                          const headers = lastWeekHeaders.map(h => h.originalHeader);
                          const data = missingInCurrentWeekRows.map(row => prepareOriginalRowForExport(row, lastWeekHeaders));
                          const worksheet = dataToWorksheet(data, headers);
                          if (worksheet) { XLSX.utils.book_append_sheet(workbook, worksheet, sheetName); sheetsAdded++; }
                     }

                     if (sheetsAdded > 0) {
                         const date = new Date();
                         const dateString = `${date.getFullYear()}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}`;
                         const fileName = `Analysis_Details_${dateString}.xlsx`;
                         XLSX.writeFile(workbook, fileName);
                         showResultsMessage(`Successfully exported "${fileName}" with ${sheetsAdded} sheet(s).`, 'success');
                     } else {
                         showResultsMessage("No data available to export for the 'Not Copied / Missing' report.", 'warning');
                     }
                 } catch (error) {
                     console.error("Error exporting Not Copied / Missing report:", error);
                     showResultsMessage(`Failed to export details report: ${error.message}`, 'error');
                 }
            });

            domElements.goBackButton?.addEventListener('click', () => {
                lastWeekFile = null; currentWeekFile = null; selectedColumns = [];
                lastWeekHeaders = []; currentWeekHeaders = []; processedReportData = null;
                notCopiedRows = []; lastWeekNotCopiedRows = []; missingInCurrentWeekRows = [];
                missingColumnsInCurrentWeek = []; finalExportHeaders = [];
                showPage('upload-page'); // Resets form via showPage logic
            });

        }); // End DOMContentLoaded

    </script>
</body>
</html>
